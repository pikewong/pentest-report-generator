using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NotesAssistant.Findings;
using Microsoft.Office.Interop.Word;

namespace NotesAssistant.ReportOutput {
    class docxOutputFormater {
        /*
         * http://www.c-sharpcorner.com/UploadFile/muralidharan.d/how-to-create-word-document-using-C-Sharp/
         * 
         * */

        enum tableItem { 
            riskLevel = 1,
            OWASP = 2,
            affected = 3,
        }

        Dictionary<string, ApplicationFindings> applicationFindingList = null;
        Microsoft.Office.Interop.Word.Application wordApp = null;
        Microsoft.Office.Interop.Word.Document wordDoc = null;
        object missing = System.Reflection.Missing.Value;

        /// <summary>
        /// Constructor
        /// </summary>
        public docxOutputFormater(ProjectFindings projectFindings) {
            applicationFindingList = projectFindings.getApplicationFindingList();
            createDocumet();
            //addHeaderFooter();
            addFindings();
        }

        /// <summary>
        /// Initialize variables
        /// </summary>
        public void createDocumet() {
            //Create an instance for word app
            wordApp = new Microsoft.Office.Interop.Word.Application();

            //Set status for word application is to be visible or not.
            wordApp.Visible = true;

            //Create a new document
            wordDoc = wordApp.Documents.Open(@"D:\GitHub\pentest-report-generator\NotesAssistant\Resources\Template\Template.docx");
        }

        /// <summary>
        /// Edit Header Footer
        /// </summary>
        private void headerFooter() {
            //Add header into the document
            foreach (Microsoft.Office.Interop.Word.Section section in wordDoc.Sections) {
                //Get the header range and add the header details.
                Microsoft.Office.Interop.Word.Range headerRange = section.Headers[Microsoft.Office.Interop.Word.WdHeaderFooterIndex.wdHeaderFooterPrimary].Range;
                headerRange.Fields.Add(headerRange, Microsoft.Office.Interop.Word.WdFieldType.wdFieldPage);
                headerRange.ParagraphFormat.Alignment = Microsoft.Office.Interop.Word.WdParagraphAlignment.wdAlignParagraphCenter;
                headerRange.Font.ColorIndex = Microsoft.Office.Interop.Word.WdColorIndex.wdBlue;
                headerRange.Font.Size = 10;
                headerRange.Text = "Header text goes here";
            }

            //Add the footers into the document
            foreach (Microsoft.Office.Interop.Word.Section wordSection in wordDoc.Sections) {
                //Get the footer range and add the footer details.
                Microsoft.Office.Interop.Word.Range footerRange = wordSection.Footers[Microsoft.Office.Interop.Word.WdHeaderFooterIndex.wdHeaderFooterPrimary].Range;
                footerRange.Font.ColorIndex = Microsoft.Office.Interop.Word.WdColorIndex.wdDarkRed;
                footerRange.Font.Size = 10;
                footerRange.ParagraphFormat.Alignment = Microsoft.Office.Interop.Word.WdParagraphAlignment.wdAlignParagraphCenter;
                footerRange.Text = "Footer text goes here";
            }
        }

        /// <summary>
        /// Adding Header
        /// </summary>
        /// <param name="heading"></param>
        /// <param name="style"></param>
        /// <param name="pageBreak"></param>
        private void addHeading(string heading, string style, bool pageBreak = true) {
            Microsoft.Office.Interop.Word.Paragraph para = wordDoc.Content.Paragraphs.Add();
            para.Range.Text = heading;
            para.Range.set_Style(wordDoc.Styles[style]);
            if (!pageBreak) {
                para.PageBreakBefore = 0;
            }
            para.Range.InsertParagraphAfter();
        }


        /// <summary>
        /// Adding Findings
        /// </summary>
        private void addFindings() {
            bool hasFinding = false;
            addHeading("Findings", "Heading 1");
            addHeading("Detailed Findings", "Heading 2");

            bool firstItem = true;
            addHeading("High Risk Findings", "Heading 3", false);
            foreach (string applicationName in applicationFindingList.Keys) {
                ApplicationFindings pentestFindings = applicationFindingList[applicationName];
                List<DataEntry> entryList = pentestFindings.getHighRisk();
                foreach (DataEntry entry in entryList) {
                    if (firstItem) {
                        addFindingContent(entry, false);
                        firstItem = false;
                    }
                    else {
                        addFindingContent(entry);
                    }
                    hasFinding = true;
                }
            }

            if (!hasFinding) {
                noFinding("high risk");
            }

            firstItem = true;
            hasFinding = false;
            addHeading("Medium Risk Findings", "Heading 3");
            foreach (string applicationName in applicationFindingList.Keys) {
                ApplicationFindings pentestFindings = applicationFindingList[applicationName];
                List<DataEntry> entryList = pentestFindings.getMediumRisk();
                foreach (DataEntry entry in entryList) {
                    hasFinding = true;
                    if (firstItem) {
                        addFindingContent(entry, false);
                        firstItem = false;
                    }
                    else {
                        addFindingContent(entry);
                    }
                    hasFinding = true;
                }
            }

            if (!hasFinding) {
                noFinding("medium risk");
            }

            firstItem = true;
            hasFinding = false;
            addHeading("Low Risk Findings", "Heading 3");
            foreach (string applicationName in applicationFindingList.Keys) {
                ApplicationFindings pentestFindings = applicationFindingList[applicationName];
                List<DataEntry> entryList = pentestFindings.getLowRisk();
                foreach (DataEntry entry in entryList) {
                    hasFinding = true;
                    if (firstItem) {
                        addFindingContent(entry, false);
                        firstItem = false;
                    }
                    else {
                        addFindingContent(entry);
                    }
                    hasFinding = true;
                }
            }

            if (!hasFinding) {
                noFinding("low risk");
            }

            firstItem = true;
            hasFinding = false;
            foreach (string applicationName in applicationFindingList.Keys) {
                ApplicationFindings pentestFindings = applicationFindingList[applicationName];
                List<DataEntry> entryList = pentestFindings.getInformational();
                if (entryList.Count > 0) {
                    hasFinding = true;
                    break;
                }
            }

            if (hasFinding) {
                addHeading("Informational Findings", "Heading 3");
                foreach (string applicationName in applicationFindingList.Keys) {
                    ApplicationFindings pentestFindings = applicationFindingList[applicationName];
                    List<DataEntry> entryList = pentestFindings.getInformational();
                    foreach (DataEntry entry in entryList) {
                        Console.WriteLine(entry.getFindingName());
                        if (firstItem) {
                            addFindingContent(entry, false);
                            firstItem = false;
                        }
                        else {
                            addFindingContent(entry);
                        }
                    }
                }
            }


        }

        /// <summary>
        /// Adding entry findings
        /// </summary>
        /// <param name="entry"></param>
        /// <param name="pageBreak"></param>
        private void addFindingContent(DataEntry entry, bool pageBreak = true) {
            addHeading(entry.getFindingName(), "Heading 4", pageBreak);
            int numOfRows = 3;
            int numOfCols = 2;
            Microsoft.Office.Interop.Word.Paragraph para = wordDoc.Content.Paragraphs.Add();

            Table findingTable = wordDoc.Tables.Add(para.Range, numOfRows, numOfCols, ref missing, ref missing);
            findingTable.Borders.Enable = 1;
            findingTable.Rows[(int)tableItem.riskLevel].Cells[1].Range.Text = "Risk Level:";
            findingTable.Rows[(int)tableItem.OWASP].Cells[1].Range.Text = "OWASP Top Ten:";
            findingTable.Rows[(int)tableItem.affected].Cells[1].Range.Text = "Affected:";

            findingTable.Rows[(int)tableItem.riskLevel].Cells[2].Range.Text = entry.getRiskLevel().ToString();
            findingTable.Rows[(int)tableItem.OWASP].Cells[2].Range.Text = entry.getOWASPString();
            findingTable.Rows[(int)tableItem.affected].Cells[2].Range.Text = entry.getAffected();

            findingTable.Range.set_Style("Body Text");

            foreach (Row row in findingTable.Rows) {
                row.Cells[1].Range.Font.Bold = 1;
            }

            findingTable.Columns[1].Width = 100;
            findingTable.Columns[2].Width = 350;

            para = wordDoc.Content.Paragraphs.Add();
            para.Range.Text = "Details";
            para.Range.set_Style(wordDoc.Styles["Heading 5"]);
            para.Range.InsertParagraphAfter();

            para = wordDoc.Content.Paragraphs.Add();
            para.Range.Text = entry.getDetails();
            para.Range.set_Style(wordDoc.Styles["Body Text"]);
            para.Range.InsertParagraphAfter();

            insertPoC(entry);

            para = wordDoc.Content.Paragraphs.Add();
            para.Range.Text = "Recommendation";
            para.Range.set_Style(wordDoc.Styles["Heading 5"]);
            para.Range.InsertParagraphAfter();

            para = wordDoc.Content.Paragraphs.Add();
            para.Range.Text = entry.getRecommendation();
            para.Range.set_Style(wordDoc.Styles["Body Text"]);
            para.Range.InsertParagraphAfter();
        }

        private void insertPoC(DataEntry entry) {

            foreach (string name in entry.getScreenshots().Keys) {
                string findText = "[[IMAGE:" + name + "]]";
                // Get the Range for the text you want to replace, which you claim to be able to do already.
                bool found = wordApp.Selection.Find.Execute(findText);
                if (found) {
                    Range selectedText = wordApp.Selection.Range;
                    // Clear the existing text, otherwise the image will just be appended after the text.
                    selectedText.Text = "";
                    // Insert the image.
                    entry.getScreenshots()[name].getImage().Save(Config.ProjectPath + "\\insertPoC.png");
                    selectedText.InsertCaption(WdCaptionLabelID.wdCaptionFigure, ": " + entry.getScreenshots()[name].getCaption(), missing, WdCaptionPosition.wdCaptionPositionBelow);
                    selectedText.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
                    selectedText.InsertParagraph();
                    selectedText.InlineShapes.AddPicture(Config.ProjectPath + "\\insertPoC.png", Type.Missing, true, Type.Missing);
                    //Microsoft.Office.Interop.Word.Paragraph para = wordDoc.Content.Paragraphs.Add();
                    //para.Range.InsertParagraphAfter();
                    selectedText.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
                }
            }
        }

        /// <summary>
        /// Print Strings when there is no findings identified
        /// </summary>
        /// <param name="level"></param>
        private void noFinding(string level) {
            Microsoft.Office.Interop.Word.Paragraph para = wordDoc.Content.Paragraphs.Add();
            para.Range.Text = "There is no " + level + " finding identified";
            para.Range.set_Style(wordDoc.Styles["Body Text"]);
            para.Range.InsertParagraphAfter();
        }

    }
}
